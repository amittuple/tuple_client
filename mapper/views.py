from django.core.urlresolvers import reverse
from django.shortcuts import render, HttpResponseRedirect

from database_management.ConnectDatabase import connect_to_client_database
from .filters import get_item
from .models import CustomerContactMappingModel, CustomerMasterMappingModel, ProductMasterMappingModel, EventLogMappingModel, EventMasterMappingModel, TransactionMasterMappingModel


# api functions


# Append List Generated By 'extract_column_name_list_of_table' to client
def attach_column_list_to_every_client_table(cursor, table_map):
    client_table_and_column_with_type = {}
    for key in table_map:
        if not table_map[key] == '':
            temporary_table = []
            temporary_table.append(table_map[key])
            column_name_list = extract_column_name_list_of_table(cursor, temporary_table)
            client_table_and_column_with_type[str(temporary_table[0])] = {}
            for item in column_name_list:
                client_table_and_column_with_type[str(temporary_table[0])][str(item[0])] = {
                    'type': str(item[1])
                }
    return client_table_and_column_with_type


# Extract Table Names From Client Database
def extract_table_name(cursor):
    list_of_tables = []
    cursor.execute("SELECT table_name FROM information_schema.tables where table_schema='public'")
    list_of_tables_temp = cursor.fetchall()
    for temp in list_of_tables_temp:
        for item in temp:
            list_of_tables.append(item)
    return list_of_tables


# Extract Column Name List Of A Particular Table Of Client
def extract_column_name_list_of_table(cur, tablename):
    # tablename should be a tuple or list of element one
    if isinstance(tablename, basestring):
        raise Exception('tablename variable must be a tuple or list of single element')
    cur.execute('SELECT column_name, data_type FROM information_schema.columns WHERE table_name = %s', tablename)
    column_name_list = cur.fetchall()
    return column_name_list


# Returns Client Db Model Names And Their Corresponding Models
def get_table_name_model_pair():
    table_name_model_pair = {
        'CUSTOMER_CONTACT': CustomerContactMappingModel,
        'CUSTOMER_MASTER': CustomerMasterMappingModel,
        'EVENT_LOG': EventLogMappingModel,
        'EVENT_MASTER': EventMasterMappingModel,
        'PRODUCT_MASTER': ProductMasterMappingModel,
        'TRANSACTION_MASTER': TransactionMasterMappingModel
    }
    return table_name_model_pair


# Append Column List To Respective Client table And Create Map
def prepare_our_model(table_map):
    our_model = {}
    #   For Customer Contact
    table_name_model_pair = get_table_name_model_pair()

    for key, value in table_name_model_pair.iteritems():
        if not table_map[key] == '':
            temporary_value = value._meta.get_fields()
            mapping_name = key
            our_model[mapping_name] = []
            for item in temporary_value:
                # To Exclude Id, Client, Client Table Name From Client HTML Page
                if item.name != 'client' and item.name !='client_table_name' and item.name != 'id':
                    our_model[mapping_name].append(item.name)
    return our_model


# Input Includes
# table_map = Mapping Of Our Table wrt To Client Table
# client_table_and_column_with_type = Mapping Of Client Table and Column List Along With There Data Types
# our_model = Mapping of Our Table and Our Columns
# request = Post Request That Contains The Client Specific Inputs
# ------------------------- NOTE: ----------------------- #
# request will be deprecated in next fix
def prepare_final_model(table_map, client_table_and_column_with_type, our_model, request):
    column_map = {}
    for key, value in our_model.iteritems():
        temp = {}
        column_map[key] = {}
        for item in value:
            temp[item] = {}
            if request.POST[key+'.'+item] == u'':
                temp[item] = None
            else:
                temp[item][request.POST[key+'.'+item]] = {}
                temp[item][request.POST[key+'.'+item]] = {
                    'type': client_table_and_column_with_type[table_map[key]][request.POST[key+'.'+item]]['type']
                }
        column_map[key][table_map[key]] = {}
        column_map[key][table_map[key]] = temp
    return column_map


# Column Mapping View
def column_mapping(request):
    if not request.user.is_authenticated:
        return HttpResponseRedirect(reverse('login'))
    user = request.user
    obj = connect_to_client_database(user)
    try:
        table_map = request.session['table_map']
        client_table_and_column_with_type = attach_column_list_to_every_client_table(obj.cur, table_map)
        print 'client_table_and_column_with_type'
        print client_table_and_column_with_type
    #   Now For Our Database
        our_model = prepare_our_model(table_map)
        print 'our_model'
        print our_model
    except KeyError as e:
        if e.message.__contains__('table_map'):
            print 'Table Mapping Should Be Done First'
            return HttpResponseRedirect(reverse('table_mapping'))
    except Exception as e:
        print e

    if request.method == 'POST':
        print request.POST
        column_map = prepare_final_model(table_map, client_table_and_column_with_type, our_model, request)
        request.session['column_map'] = column_map
        print column_map
        return HttpResponseRedirect(reverse('mapping_review'))

    return render(request, 'mapper/column-mapping.html', {
        'client_table_and_column_with_type': client_table_and_column_with_type,
        'our_model': our_model,
        'table_map': table_map,
        'get_item': get_item
    })


# Table Mapping View
def table_mapping(request):
    if not request.user.is_authenticated:
        return HttpResponseRedirect(reverse('login'))
    list_of_headings = []
    for item in get_table_name_model_pair():
        list_of_headings.append(item)
    # list_of_headings = ['TRANSACTION_MASTER', 'PRODUCT_MASTER', 'EVENT_MASTER', 'CUSTOMER_CONTACT', 'EVENT_LOG', 'CUSTOMER_MASTER']
    user = request.user
    list_of_tables = []
    try:
        list_of_tables = request.session['list_of_tables']
    except KeyError as e:
        if e.message.__contains__('list_of_tables'):
            obj = connect_to_client_database(user)
            if not obj.isConnected():
                raise Exception('Client Database Connection Configuration Missing.')
            list_of_tables = extract_table_name(obj.cur)
            obj.cur.close()
            obj.conn.close()
            request.session['list_of_tables'] = list_of_tables
    except Exception as e:
        print e

    if request.method == 'POST':
        table_map = {}
        for item in list_of_headings:
                table_map[str(item)] = str(request.POST[item])
        request.session['table_map'] = table_map
        print 'table_map'
        print table_map
        return HttpResponseRedirect(reverse('column_mapping'))

    return render(request, 'mapper/table-mapping.html', {
        'list_of_tables': list_of_tables,
        'list_of_headings': list_of_headings,
    })

# Save Mapping Into Model
# Parameters Include
# table_name_model_pair = Includes Client Db Model And Its Mapping
# column_map = Final Mapping Dictionary Of User Custom Mapping
# user = SimpleLazyObject of request.user
def save_mapping_into_model(table_name_model_pair, column_map, user):
    for our_table_name, client_table_list in column_map.iteritems():
        obj = table_name_model_pair[our_table_name]()
        for our_column_name, client_column_list in column_map[our_table_name][client_table_list.keys()[0]].iteritems():
            # print our_column_name
            if client_column_list is not None:
                # print client_column_list.keys()[0]
                setattr(obj, our_column_name, client_column_list.keys()[0])
        # Not To Be Inputted By Client
        setattr(obj, 'client', user)
        setattr(obj, 'client_table_name', client_table_list.keys()[0])
        try:
            if table_name_model_pair[our_table_name].objects.get(client=user):
                print our_table_name + ' Mapping Already Exists'
                print 'Skip'
            else:
                obj.save()
        except Exception as e:
            if e.message.__contains__('matching query'):
                obj.save()


# Mapping Review View
def mapping_review(request):
    if not request.user.is_authenticated:
        return HttpResponseRedirect(reverse('login'))
    try:
        column_map = request.session['column_map']
    except KeyError:
        print 'No Mapping Defined Please Do Mapping Before'
        return HttpResponseRedirect(reverse('column_mapping'))
    user = request.user
    if request.method == 'POST':
        table_name_model_pair = get_table_name_model_pair()
        # print table_name_model_pair
        save_mapping_into_model(table_name_model_pair, column_map, user)
        request.session['transfer_database_flag'] = True
        return HttpResponseRedirect(reverse('transfer_database'))
    return render(request, 'mapper/mapping-review.html', {
        'column_map': column_map,
        'get_item': get_item
    })
